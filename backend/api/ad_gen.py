# -*- coding: utf-8 -*-
"""AdGen Backend

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zB9_V8wVoYfPpQL_vp0W1wIwTBHOwvPc
"""

import os
import json
import time
import io
import base64
import tempfile
import logging
from functools import wraps
from flask import Blueprint, request, jsonify, g, current_app
from PIL import Image

try:
    from moviepy.editor import VideoFileClip, AudioFileClip, CompositeAudioClip
except ImportError:
    print("WARNING: moviepy not installed. Run 'pip install moviepy'. Merging will fail.")
    VideoFileClip = None
    AudioFileClip = None
    CompositeAudioClip = None

import google.generativeai as genai
from google.generativeai import types
import google.auth.transport.requests
from google.oauth2 import id_token
import firebase_admin
from firebase_admin import credentials, auth, firestore, storage

ad_gen_bp = Blueprint('ad_gen_bp', __name__, url_prefix='/ads')

db = None
bucket = None
media_client = None
genai_llm = None

VEO_MODEL = "veo-3.1-generate-preview"
LYRIA_MODEL = "lyria-2.0-preview"
IMAGE_MODEL = "gemini-2.5-flash-image"
LLM_MODEL = "gemini-2.5-flash-preview-09-2025"
VIDEO_DURATION_SECONDS = 15


def init_ad_gen_services(app):
    """
    Initializes all external clients for this blueprint.
    Call this from your main app.py on startup, passing in the Flask 'app' object.
    """
    global db, bucket, media_client, genai_llm


    app.logger.info("Initializing Ad Generation Services (Firebase/Google)...")


    try:

        if not firebase_admin._apps:
            cred_json_str = os.getenv('FIREBASE_SERVICE_ACCOUNT_JSON')
            if cred_json_str:
                app.logger.info("Initializing Firebase from environment variable...")
                cred_json = json.loads(cred_json_str)
                cred = credentials.Certificate(cred_json)
            else:
                app.logger.info("Initializing Firebase from 'firebase-service-account.json' file...")
                cred = credentials.Certificate('firebase-service-account.json')

            firebase_admin.initialize_app(cred, {
                'storageBucket': os.getenv('FIREBASE_STORAGE_BUCKET')
            })
            app.logger.info("Firebase Admin SDK initialized successfully.")
        else:
             app.logger.info("Firebase Admin SDK already initialized by main app.")

        db = firestore.client()
        bucket = storage.bucket()

    except Exception as e:
        app.logger.error(f"Failed to initialize Firebase Admin SDK: {e}")
        app.logger.error("Please ensure FIREBASE_SERVICE_ACCOUNT_JSON (env var) or 'firebase-service-account.json' (file) is set.")
        app.logger.error(f"Also ensure FIREBASE_STORAGE_BUCKET (env var) is set to your bucket name (e.g., 'my-project.appspot.com')")



    try:
        GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
        if not GOOGLE_API_KEY:
            raise ValueError("GOOGLE_API_KEY not set in .env file")


        media_client = genai.Client(api_key=GOOGLE_API_KEY)


        genai.configure(api_key=GOOGLE_API_KEY)
        genai_llm = genai.GenerativeModel(LLM_MODEL)

        app.logger.info("Google GenAI Clients initialized successfully.")
    except Exception as e:
        app.logger.error(f"Error initializing Google clients: {e}")


def verify_firebase_token(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):

        if not db and os.getenv('FLASK_ENV') != 'production':
            current_app.logger.warning("!!! AUTHENTICATION BYPASSED - FOR DEVELOPMENT ONLY !!!")
            current_app.logger.warning("Firebase not initialized. Using 'test-user-id'.")
            g.user_id = "test-user-id"
            return f(*args, **kwargs)
        elif not db:
             current_app.logger.error("Firebase not initialized. Auth failed.")
             return jsonify({"error": "Server configuration error"}), 500

        token = None
        if 'Authorization' in request.headers:
            token = request.headers.get('Authorization').split('Bearer ').pop()

        if not token:
            return jsonify({"error": "Authorization token is missing"}), 401

        try:

            decoded_token = auth.verify_id_token(token)

            g.user_id = decoded_token['uid']
        except auth.InvalidIdTokenError:
            current_app.logger.warning(f"Invalid auth token received.")
            return jsonify({"error": "Invalid authorization token"}), 401
        except Exception as e:
            current_app.logger.error(f"Authentication error: {e}")
            return jsonify({"error": f"Authentication error: {str(e)}"}), 500

        return f(*args, **kwargs)
    return decorated_function



def merge_ad(video_path, music_path, video_duration):
    """
    Merges a video and audio file using moviepy.
    Returns the path to the final merged temp file.
    """
    if not VideoFileClip:
        current_app.logger.error("MoviePy is not imported. Cannot merge files.")
        raise ImportError("MoviePy library not found")

    try:
        current_app.logger.info(f"Merging video {video_path} and audio {music_path}")
        video_clip = VideoFileClip(video_path)
        audio_clip = AudioFileClip(music_path)

        if audio_clip.duration > video_duration:
            audio_clip = audio_clip.subclip(0, video_duration)
        elif audio_clip.duration < video_duration:
            from moviepy.video.fx.all import loop
            audio_clip = audio_clip.fx(loop, duration=video_duration)

        final_clip = video_clip.set_audio(audio_clip)

        with tempfile.NamedTemporaryFile(suffix=".mp4", delete=False) as temp_final:
            final_path = temp_final.name
            current_app.logger.info(f"Writing merged file to {final_path}")
            final_clip.write_videofile(final_path, codec="libx264", audio_codec="aac", bitrate="5000k", preset="medium", logger=None)

        video_clip.close()
        audio_clip.close()
        final_clip.close()

        current_app.logger.info("Merge complete.")
        return final_path

    except Exception as e:
        current_app.logger.exception(f"Error during video/audio merge: {e}")
        if 'video_clip' in locals() and video_clip: video_clip.close()
        if 'audio_clip' in locals() and audio_clip: audio_clip.close()
        if 'final_clip' in locals() and final_clip: final_clip.close()
        raise

def cleanup_temp_files(*files):
    """Safely deletes one or more temporary files."""
    for f in files:
        if f and os.path.exists(f):
            try:
                os.remove(f)
                current_app.logger.info(f"Cleaned up temp file: {f}")
            except Exception as e:
                current_app.logger.warning(f"Failed to clean up temp file {f}: {e}")


def upload_to_firebase_storage(file_path, user_id, operation_name):
    """Uploads a file to Firebase Storage and returns its public URL."""
    if not bucket:
        current_app.logger.error("Firebase Storage not initialized. Skipping upload.")
        return f"http://fake-storage-url.com/{operation_name}.mp4"

    destination_blob_name = f'users/{user_id}/videos/merged/{operation_name}.mp4'
    blob = bucket.blob(destination_blob_name)

    current_app.logger.info(f"Uploading from {file_path} to {destination_blob_name}...")
    try:
        blob.upload_from_filename(file_path)
        blob.make_public()
        current_app.logger.info("Upload complete. File made public.")
        return blob.public_url
    except Exception as e:
        current_app.logger.error(f"Failed to upload to Firebase Storage: {e}")
        raise

def save_video_metadata_to_firestore(user_id, job_data, video_url, operation_name):
    """Saves final video metadata to the user's collection in Firestore."""
    if not db:
        current_app.logger.error("Firestore not initialized. Skipping metadata save.")
        return

    try:
        user_videos_ref = db.collection('users').document(user_id).collection('videos')
        video_doc = {
            'video_prompt': job_data.get('video_prompt'),
            'music_prompt': job_data.get('music_prompt'),
            'video_url': video_url,
            'operation_name': operation_name,
            'created_at': firestore.SERVER_TIMESTAMP
        }
        user_videos_ref.add(video_doc)

        job_ref = db.collection('video_jobs').document(operation_name)
        job_ref.set({
            'final_status': 'complete',
            'final_video_url': video_url,
            'updated_at': firestore.SERVER_TIMESTAMP
        }, merge=True)
        current_app.logger.info(f"Firestore metadata saved for user {user_id}.")
    except Exception as e:
        current_app.logger.error(f"Failed to save metadata to Firestore: {e}")
        raise


def start_ad_generation_jobs(video_prompt, music_prompt, image=None):
    """
    Helper to start Veo and Lyria jobs and create the master job doc.
    """
    if not media_client:
         current_app.logger.error("Media client not initialized")
         raise Exception("Media client not initialized")
    if not db:
        current_app.logger.error("Firestore not initialized")
        raise Exception("Firestore not initialized")

    current_app.logger.info(f"Starting Veo job for user {g.user_id}...")
    video_args = {
        "model": VEO_MODEL,
        "prompt": video_prompt,
        "duration_seconds": VIDEO_DURATION_SECONDS
    }
    if image:
        video_args["image"] = image

    video_operation = media_client.models.generate_videos(**video_args)
    video_op_name = video_operation.operation.name
    current_app.logger.info(f"Veo job started. Operation name: {video_op_name}")

    music_op_name = None
    if music_prompt:
        try:
            current_app.logger.info(f"Starting Lyria job for user {g.user_id}...")
            music_operation = media_client.models.generate_music(
                model=LYRIA_MODEL,
                prompt=music_prompt,
                duration_seconds=VIDEO_DURATION_SECONDS
            )
            music_op_name = music_operation.operation.name
            current_app.logger.info(f"Lyria job started. Operation name: {music_op_name}")
        except Exception as e:
            current_app.logger.error(f"Failed to start Lyria job, continuing with video only: {e}")
            music_op_name = None

    job_ref = db.collection('video_jobs').document(video_op_name)
    job_data = {
        'user_id': g.user_id,
        'video_prompt': video_prompt,
        'video_op_name': video_op_name,
        'video_status': 'processing',
        'final_status': 'processing',
        'created_at': firestore.SERVER_TIMESTAMP,
        'has_image_input': (image is not None)
    }
    if music_op_name:
        job_data['music_prompt'] = music_prompt
        job_data['music_op_name'] = music_op_name
        job_data['music_status'] = 'processing'
    else:
        job_data['music_status'] = 'skipped'

    job_ref.set(job_data)

    return video_op_name



@ad_gen_bp.route('/generate-prompt', methods=['POST'])
@verify_firebase_token
def generate_prompt():
    """
    Takes a user's startup idea and generates a video/music prompt JSON.
    Input: {"idea": "An app for..."}
    Output: {"video_prompt": "...", "music_prompt": "..."}
    """
    if not genai_llm:
         current_app.logger.error("LLM client not initialized")
         return jsonify({"error": "LLM client not initialized"}), 500

    data = request.json
    if 'idea' not in data:
        return jsonify({"error": "Missing 'idea' in request body"}), 400
    user_idea = data['idea']

    system_prompt = f"""
    You are a world-class creative director for a marketing agency.
    A user will provide a startup idea. Your job is to generate two distinct prompts for AI models, formatted as a JSON object.
    1. "video_prompt": A {VIDEO_DURATION_SECONDS}-second, visually descriptive video prompt for Veo 3.1. It should describe scenes, camera movements, and any spoken dialogue (e.g., "Man says: 'This is amazing!'").
    2. "music_prompt": A prompt for Lyria (music model) describing the background music for a {VIDEO_DURATION_SECONDS}-second ad (e.g., "upbeat, hopeful, electronic track").

    Ensure the JSON is valid.
    """

    generation_config = types.GenerationConfig(
        response_mime_type="application/json",
        response_schema={
            "type": "OBJECT",
            "properties": {
                "video_prompt": {"type": "STRING"},
                "music_prompt": {"type": "STRING"}
            },
            "required": ["video_prompt", "music_prompt"]
        }
    )

    try:
        llm_with_schema = genai.GenerativeModel(
            LLM_MODEL,
            generation_config=generation_config,
            system_instruction=system_prompt
        )
        response = llm_with_schema.generate_content(user_idea)
        prompt_data = json.loads(response.text)
        return jsonify(prompt_data), 200
    except Exception as e:
        current_app.logger.exception(f"Error in /ads/generate-prompt: {e}")
        return jsonify({"error": f"Failed to generate prompt: {str(e)}"}), 500


@ad_gen_bp.route('/generate-image', methods=['POST'])
@verify_firebase_token
def generate_image_api():
    """
    Generates an image from a text prompt and returns it as base64.
    Input: {"prompt": "A calico kitten..."}
    Output: {"image_b64": "..."}
    """
    if not media_client:
         current_app.logger.error("Media client not initialized")
         return jsonify({"error": "Media client not initialized"}), 500

    data = request.json
    if 'prompt' not in data:
        return jsonify({"error": "Missing 'prompt' in request body"}), 400
    prompt = data['prompt']

    try:
        current_app.logger.info(f"Generating image with prompt: {prompt[:50]}...")
        image_response = media_client.models.generate_content(
            model=IMAGE_MODEL,
            contents=prompt,
            config={"response_modalities":['IMAGE']}
        )

        pil_image = image_response.parts[0].as_image()

        buf = io.BytesIO()
        pil_image.save(buf, format="PNG")
        img_b64 = base64.b64encode(buf.getvalue()).decode("utf-8")

        current_app.logger.info("Image generated successfully.")
        return jsonify({"image_b64": img_b64}), 200
    except Exception as e:
        current_app.logger.exception(f"Error in /ads/generate-image: {e}")
        return jsonify({"error": f"Failed to generate image: {str(e)}"}), 500


@ad_gen_bp.route('/generate-video-text', methods=['POST'])
@verify_firebase_token
def generate_video_from_text():
    """
    Kicks off a text-to-video AND music generation job.
    Input: {"video_prompt": "...", "music_prompt": "..."}
    Output: {"status": "processing", "operation_name": "..."}
    """
    data = request.json
    if 'video_prompt' not in data:
        return jsonify({"error": "Missing 'video_prompt' in request body"}), 400

    video_prompt = data['video_prompt']
    music_prompt = data.get('music_prompt')

    try:
        operation_name = start_ad_generation_jobs(video_prompt, music_prompt, image=None)
        return jsonify({"status": "processing", "operation_name": operation_name}), 202
    except Exception as e:
        current_app.logger.exception(f"Error in /ads/generate-video-text: {e}")
        return jsonify({"error": f"Failed to start video generation: {str(e)}"}), 500


@ad_gen_bp.route('/generate-video-image', methods=['POST'])
@verify_firebase_token
def generate_video_from_image():
    """
    Kicks off an image-to-video AND music generation job.
    Input: {"prompt": "...", "image_b64": "...", "music_prompt": "..."}
    Output: {"status": "processing", "operation_name": "..."}
    """
    data = request.json
    if 'prompt' not in data or 'image_b64' not in data:
        return jsonify({"error": "Missing 'prompt' or 'image_b64' in request body"}), 400

    video_prompt = data['prompt']
    image_b64 = data['image_b64']
    music_prompt = data.get('music_prompt')

    try:
        img_data = base64.b64decode(image_b64)
        pil_image = Image.open(io.BytesIO(img_data))

        operation_name = start_ad_generation_jobs(video_prompt, music_prompt, image=pil_image)
        return jsonify({"status": "processing", "operation_name": operation_name}), 202
    except Exception as e:
        current_app.logger.exception(f"Error in /ads/generate-video-image: {e}")
        return jsonify({"error": f"Failed to start video generation: {str(e)}"}), 500


@ad_gen_bp.route('/video-status/<operation_name>', methods=['GET'])
@verify_firebase_token
def get_video_status(operation_name):
    """
    Polls the status of a master generation job (video + music).
    """
    if not media_client or not db:
         current_app.logger.error("Services not initialized (Media/DB)")
         return jsonify({"error": "Server services not initialized"}), 500

    try:
        job_ref = db.collection('video_jobs').document(operation_name)
        job_doc = job_ref.get()

        if not job_doc.exists:
            current_app.logger.warning(f"Job not found: {operation_name}")
            return jsonify({"error": "Job not found"}), 404

        job_data = job_doc.to_dict()
        if job_data.get('user_id') != g.user_id:
            current_app.logger.warning(f"Forbidden access attempt by user {g.user_id} for job {operation_name}")
            return jsonify({"error": "Forbidden"}), 403

        final_status = job_data.get('final_status')
        if final_status == 'complete':
            return jsonify({
                "status": "complete",
                "video_url": job_data.get('final_video_url')
            }), 200
        if final_status in ['merging', 'failed']:
            return jsonify({"status": final_status, "error": job_data.get("error_message")}), 200

        update_data = {}
        video_status = job_data.get('video_status')
        music_status = job_data.get('music_status')

        if video_status == 'processing':
            video_op_name = job_data.get('video_op_name')
            current_app.logger.info(f"Polling Veo op: {video_op_name}")
            video_op = media_client.operations.get(video_op_name)

            if video_op.done:
                if video_op.error:
                    current_app.logger.error(f"Veo job {video_op_name} failed: {video_op.error.message}")
                    update_data['video_status'] = 'failed'
                    update_data['final_status'] = 'failed'
                    update_data['error_message'] = f"Video generation failed: {video_op.error.message}"
                else:
                    current_app.logger.info(f"Veo job {video_op_name} complete. Downloading...")
                    video_file = video_op.response.generated_videos[0]
                    with tempfile.NamedTemporaryFile(suffix=".mp4", delete=False) as temp_video:
                        video_file.video.save(temp_video.name)
                        update_data['video_status'] = 'downloaded'
                        update_data['video_temp_path'] = temp_video.name
                        current_app.logger.info(f"Veo video saved to {temp_video.name}")

        if music_status == 'processing':
            music_op_name = job_data.get('music_op_name')
            current_app.logger.info(f"Polling Lyria op: {music_op_name}")
            music_op = media_client.operations.get(music_op_name)

            if music_op.done:
                if music_op.error:
                    current_app.logger.error(f"Lyria job {music_op_name} failed: {music_op.error.message}")
                    update_data['music_status'] = 'failed'
                else:
                    current_app.logger.info(f"Lyria job {music_op_name} complete. Downloading...")
                    music_file = music_op.response.generated_music[0]
                    with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as temp_music:
                        music_file.music.save(temp_music.name)
                        update_data['music_status'] = 'downloaded'
                        update_data['music_temp_path'] = temp_music.name
                        current_app.logger.info(f"Lyria music saved to {temp_music.name}")

        if update_data:
            job_ref.update(update_data)
            job_data.update(update_data)

        video_status = job_data.get('video_status')
        music_status = job_data.get('music_status')

        if (video_status == 'downloaded' and
            music_status in ['downloaded', 'skipped', 'failed']):

            job_ref.update({'final_status': 'merging'})
            video_path = job_data.get('video_temp_path')
            music_path = job_data.get('music_temp_path')

            try:
                if music_path:
                    final_ad_path = merge_ad(video_path, music_path, VIDEO_DURATION_SECONDS)
                else:
                    final_ad_path = video_path

                final_video_url = upload_to_firebase_storage(final_ad_path, g.user_id, operation_name)
                save_video_metadata_to_firestore(g.user_id, job_data, final_video_url, operation_name)
                cleanup_temp_files(video_path, music_path, final_ad_path)

                return jsonify({"status": "complete", "video_url": final_video_url}), 200

            except Exception as e:
                job_ref.update({
                    'final_status': 'failed',
                    'error_message': f"Ad merging failed: {str(e)}"
                })
                cleanup_temp_files(video_path, music_path)
                return jsonify({"status": "failed", "error": f"Ad merging failed: {str(e)}"}), 500

        return jsonify({"status": "processing"}), 200

    except Exception as e:
        current_app.logger.exception(f"Error in /ads/video-status for op {operation_name}: {e}")
        try:
            db.collection('video_jobs').document(operation_name).update({
                'final_status': 'failed',
                'error_message': f"Unhandled server error: {str(e)}"
            })
        except Exception as fe:
            current_app.logger.error(f"Could not even mark job as failed: {fe}")
        return jsonify({"error": f"Failed to get video status: {str(e)}"}), 500

